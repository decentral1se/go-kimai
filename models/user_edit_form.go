// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UserEditForm user edit form
//
// swagger:model UserEditForm
type UserEditForm struct {

	// account number
	AccountNumber string `json:"accountNumber,omitempty"`

	// alias
	Alias string `json:"alias,omitempty"`

	// The hexadecimal color code (default: #d2d6de)
	Color string `json:"color,omitempty"`

	// email
	// Required: true
	Email *string `json:"email"`

	// enabled
	Enabled bool `json:"enabled,omitempty"`

	// language
	// Required: true
	// Enum: [ar cs da de de_AT de_CH el en en_GB eo es eu fa fi fo fr he hr hu it ja ko nb_NO nl pl pt pt_BR ro ru sk sv tr uk vi zh_CN]
	Language *string `json:"language"`

	// roles
	Roles []string `json:"roles"`

	// timezone
	// Required: true
	Timezone *string `json:"timezone"`

	// title
	Title string `json:"title,omitempty"`
}

// Validate validates this user edit form
func (m *UserEditForm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimezone(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UserEditForm) validateEmail(formats strfmt.Registry) error {

	if err := validate.Required("email", "body", m.Email); err != nil {
		return err
	}

	return nil
}

var userEditFormTypeLanguagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ar","cs","da","de","de_AT","de_CH","el","en","en_GB","eo","es","eu","fa","fi","fo","fr","he","hr","hu","it","ja","ko","nb_NO","nl","pl","pt","pt_BR","ro","ru","sk","sv","tr","uk","vi","zh_CN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userEditFormTypeLanguagePropEnum = append(userEditFormTypeLanguagePropEnum, v)
	}
}

const (

	// UserEditFormLanguageAr captures enum value "ar"
	UserEditFormLanguageAr string = "ar"

	// UserEditFormLanguageCs captures enum value "cs"
	UserEditFormLanguageCs string = "cs"

	// UserEditFormLanguageDa captures enum value "da"
	UserEditFormLanguageDa string = "da"

	// UserEditFormLanguageDe captures enum value "de"
	UserEditFormLanguageDe string = "de"

	// UserEditFormLanguageDeAT captures enum value "de_AT"
	UserEditFormLanguageDeAT string = "de_AT"

	// UserEditFormLanguageDeCH captures enum value "de_CH"
	UserEditFormLanguageDeCH string = "de_CH"

	// UserEditFormLanguageEl captures enum value "el"
	UserEditFormLanguageEl string = "el"

	// UserEditFormLanguageEn captures enum value "en"
	UserEditFormLanguageEn string = "en"

	// UserEditFormLanguageEnGB captures enum value "en_GB"
	UserEditFormLanguageEnGB string = "en_GB"

	// UserEditFormLanguageEo captures enum value "eo"
	UserEditFormLanguageEo string = "eo"

	// UserEditFormLanguageEs captures enum value "es"
	UserEditFormLanguageEs string = "es"

	// UserEditFormLanguageEu captures enum value "eu"
	UserEditFormLanguageEu string = "eu"

	// UserEditFormLanguageFa captures enum value "fa"
	UserEditFormLanguageFa string = "fa"

	// UserEditFormLanguageFi captures enum value "fi"
	UserEditFormLanguageFi string = "fi"

	// UserEditFormLanguageFo captures enum value "fo"
	UserEditFormLanguageFo string = "fo"

	// UserEditFormLanguageFr captures enum value "fr"
	UserEditFormLanguageFr string = "fr"

	// UserEditFormLanguageHe captures enum value "he"
	UserEditFormLanguageHe string = "he"

	// UserEditFormLanguageHr captures enum value "hr"
	UserEditFormLanguageHr string = "hr"

	// UserEditFormLanguageHu captures enum value "hu"
	UserEditFormLanguageHu string = "hu"

	// UserEditFormLanguageIt captures enum value "it"
	UserEditFormLanguageIt string = "it"

	// UserEditFormLanguageJa captures enum value "ja"
	UserEditFormLanguageJa string = "ja"

	// UserEditFormLanguageKo captures enum value "ko"
	UserEditFormLanguageKo string = "ko"

	// UserEditFormLanguageNbNO captures enum value "nb_NO"
	UserEditFormLanguageNbNO string = "nb_NO"

	// UserEditFormLanguageNl captures enum value "nl"
	UserEditFormLanguageNl string = "nl"

	// UserEditFormLanguagePl captures enum value "pl"
	UserEditFormLanguagePl string = "pl"

	// UserEditFormLanguagePt captures enum value "pt"
	UserEditFormLanguagePt string = "pt"

	// UserEditFormLanguagePtBR captures enum value "pt_BR"
	UserEditFormLanguagePtBR string = "pt_BR"

	// UserEditFormLanguageRo captures enum value "ro"
	UserEditFormLanguageRo string = "ro"

	// UserEditFormLanguageRu captures enum value "ru"
	UserEditFormLanguageRu string = "ru"

	// UserEditFormLanguageSk captures enum value "sk"
	UserEditFormLanguageSk string = "sk"

	// UserEditFormLanguageSv captures enum value "sv"
	UserEditFormLanguageSv string = "sv"

	// UserEditFormLanguageTr captures enum value "tr"
	UserEditFormLanguageTr string = "tr"

	// UserEditFormLanguageUk captures enum value "uk"
	UserEditFormLanguageUk string = "uk"

	// UserEditFormLanguageVi captures enum value "vi"
	UserEditFormLanguageVi string = "vi"

	// UserEditFormLanguageZhCN captures enum value "zh_CN"
	UserEditFormLanguageZhCN string = "zh_CN"
)

// prop value enum
func (m *UserEditForm) validateLanguageEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, userEditFormTypeLanguagePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UserEditForm) validateLanguage(formats strfmt.Registry) error {

	if err := validate.Required("language", "body", m.Language); err != nil {
		return err
	}

	// value enum
	if err := m.validateLanguageEnum("language", "body", *m.Language); err != nil {
		return err
	}

	return nil
}

var userEditFormRolesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ROLE_TEAMLEAD","ROLE_ADMIN","ROLE_SUPER_ADMIN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userEditFormRolesItemsEnum = append(userEditFormRolesItemsEnum, v)
	}
}

func (m *UserEditForm) validateRolesItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, userEditFormRolesItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UserEditForm) validateRoles(formats strfmt.Registry) error {
	if swag.IsZero(m.Roles) { // not required
		return nil
	}

	for i := 0; i < len(m.Roles); i++ {

		// value enum
		if err := m.validateRolesItemsEnum("roles"+"."+strconv.Itoa(i), "body", m.Roles[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *UserEditForm) validateTimezone(formats strfmt.Registry) error {

	if err := validate.Required("timezone", "body", m.Timezone); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this user edit form based on context it is used
func (m *UserEditForm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *UserEditForm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UserEditForm) UnmarshalBinary(b []byte) error {
	var res UserEditForm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
